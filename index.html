<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>School transportation</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.js"></script>
<style>
body { margin: 0; padding: 0; }
#map { position: absolute; top: 0; bottom: 0; width: 100%; }
</style>
</head>
<body>
<style>
    button {
        position: absolute;
        margin: 20px;
    }

    #pause::after {
        content: 'Pause';
    }

    #pause.pause::after {
        content: 'Play';
    }
</style>
<div id="map"></div>

<script>

    const defaultCenter = [-76.619, 39.292];
    const defaultZoom = 11;
    const marylandBounds = [[-79.4877, 37.8855], [-75.0489, 39.723]];


	mapboxgl.accessToken = 'pk.eyJ1IjoicnlhbmxpdHRsZSIsImEiOiJjbGFiODV2dmcwMWlmM25wcXlrYzlwdzJzIn0.Tc5W4hPge3Q-Ql8EzRzTMw';
    const map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/ryanlittle/cm3nh7x9k00r801rv5xpxftzt',
        center: defaultCenter,
        zoom: defaultZoom,
        maxBounds: marylandBounds
    });

    const speedFactor = 50; // Adjust animation speed
    let animation; // Animation frame ID
    let progress = 0;
    let resetTime = false;
    let startTime = 0;

    map.on('load', () => {
        map.addSource('line', {
            'type': 'vector',
            'url': 'mapbox://ryanlittle.burin97r'
        });

        // add the line which will be modified in the animation
        map.addLayer({
            'id': 'line-animation',
            'type': 'line',
            'source': 'line',
            'source-layer': 'brooke_bourne_test-41zn9m',
            'layout': {
                'line-cap': 'round',
                'line-join': 'round'
            },
            'paint': {
                'line-color': '#999',
                'line-width': 3,
                'line-opacity': 0.5
            }
        });

        map.addSource('line-animation', {
        'type': 'geojson',
        'data': {
            'type': 'FeatureCollection',
            'features': [
                {
                    'type': 'Feature',
                    'geometry': {
                        'type': 'LineString',
                        'coordinates': []
                    }
                }
            ]
        }
    });


    map.addLayer({
        'id': 'line-animated',
        'type': 'line',
        'source': 'line-animation',
        'layout': {
            'line-cap': 'round',
            'line-join': 'round'
        },
        'paint': {
            'line-color': '#ed6498',
            'line-width': 5,
            'line-opacity': 0.8
        }
    });

    map.on('idle', () => {
    const features = map.querySourceFeatures('line', {
        sourceLayer: 'brooke_bourne_test-41zn9m'
    });

    console.log('Queried Features:', features);

    // Filter all features with the same `from_id`
    const targetFeatures = features.filter(feature => feature.properties.from_id === 'x24510080800');

    if (!targetFeatures || targetFeatures.length === 0) {
        console.error('No target features found.');
        return;
    }

    console.log('Target Features:', targetFeatures);

    // Sort features by segment to ensure proper order
    targetFeatures.sort((a, b) => a.properties.segment - b.properties.segment);

    // Combine all segment coordinates
    const combinedCoordinates = targetFeatures
        .map(feature => feature.geometry.coordinates)
        .flat();

    // Remove duplicate points to ensure a smooth line
    const uniqueCoordinates = combinedCoordinates.filter((coord, index, self) => {
        return (
            index === 0 ||
            coord[0] !== self[index - 1][0] ||
            coord[1] !== self[index - 1][1]
        );
    });

    console.log('Combined Coordinates:', uniqueCoordinates);

    if (!uniqueCoordinates || uniqueCoordinates.length === 0) {
        console.error('No coordinates found for the combined route.');
        return;
    }

    // Start animation with the combined coordinates
    startTime = performance.now();
    animateLine(uniqueCoordinates);

    function animateLine(coordinates, timestamp) {
        if (resetTime) {
            startTime = performance.now() - progress;
            resetTime = false;
        } else {
            progress = timestamp - startTime;
        }

        // Restart animation if it completes
        if (progress > speedFactor * coordinates.length) {
            startTime = performance.now();
            map.getSource('line-animation').setData({
                type: 'FeatureCollection',
                features: [
                    {
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: [] // Reset to start the animation cleanly
                        }
                    }
                ]
            });
            return; // Exit the frame to restart cleanly
        }

        const currentIndex = Math.floor(progress / speedFactor);
        if (currentIndex < coordinates.length) {
            const partialCoordinates = coordinates.slice(0, currentIndex + 1);
            map.getSource('line-animation').setData({
                type: 'FeatureCollection',
                features: [
                    {
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: partialCoordinates
                        }
                    }
                ]
            });
        }

        animation = requestAnimationFrame((timestamp) => animateLine(coordinates, timestamp));
    }
});



    
//         // Query the features from the tileset
//         map.on('idle', () => {
//         const features = map.querySourceFeatures('line', {
//             sourceLayer: 'brooke_bourne_test-41zn9m'
//         });

//         console.log('Queried Features:', features);

//         // Ensure features are returned
//         if (!features || features.length === 0) {
//             console.error('No features found in the tileset.');
//             return;
//         }

//         // Find the target feature based on the `from_id`
//         const targetFeature = features.find(feature => feature.properties.from_id === 'x24510080800');

//         if (!targetFeature) {
//             console.error('Target feature not found.');
//             return;
//         }

//         console.log('Target Feature:', targetFeature);

//         // Extract the geometry (coordinates) from the feature
//         const coordinates = targetFeature.geometry.coordinates;

//         if (!coordinates || coordinates.length === 0) {
//             console.error('No coordinates found for the target feature.');
//             return;
//         }

//         console.log('Coordinates:', coordinates);

//         startTime = performance.now();
//         animateLine();

//         function animateLine(timestamp) {
//             if (resetTime) {
//                 // Resume from previous progress
//                 startTime = performance.now() - progress;
//                 resetTime = false;
//             } else {
//                 progress = timestamp - startTime;
//             }

//             // Restart if it finishes a loop
//             if (progress > speedFactor * coordinates.length) {
//                 startTime = performance.now();
//                 map.getSource('line-animation').setData({
//                     type: 'FeatureCollection',
//                     features: [
//                         {
//                             type: 'Feature',
//                             geometry: {
//                                 type: 'LineString',
//                                 coordinates: []
//                             }
//                         }
//                     ]
//                 });
//                 return;
//             } 

//             const currentIndex = Math.floor(progress / speedFactor);

//             if (currentIndex < coordinates.length) {
//             const partialCoordinates = coordinates.slice(0, currentIndex + 1);
//             const animatedSource = map.getSource('line-animation');
//             if (
//                 animatedSource._data.features[0].geometry.coordinates.length !== partialCoordinates.length
//             ) {
//                 map.getSource('line-animation').setData({
//                     type: 'FeatureCollection',
//                     features: [
//                         {
//                             type: 'Feature',
//                             geometry: {
//                                 type: 'LineString',
//                                 coordinates: partialCoordinates
//                             }
//                         }
//                     ]
//                 });
//             }
//         }

//         animation = requestAnimationFrame(animateLine);
//     }
// });
    });
</script> 

</body>
</html>